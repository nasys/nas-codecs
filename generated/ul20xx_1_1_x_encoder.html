
<!DOCTYPE html>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<html>
<head>
<style>
    body {background-color: white; font-family: Helvetica; font-weight: lighter; margin: 0px;}
    h2   {background-color: #004f9e; color: white; font-weight:normal; padding: 10px; margin-block-start:0em;}
    label2 {padding: 10px; margin-block-start:0em;}
    pre  {font-family: monospace; font-size: 9.5pt;}
    span.dim {color: #bbbbbb;}
    .footer{position: fixed; text-align: left; bottom: 0px; width: 100%; color: #bbbbbb; background-color: white; padding-left: 10px; font-size: 9pt;}
</style>
</head>
<body>
<h2>NAS UL20xx Payload Encoder for 1.1.x</h2><br>
<label2>Supported devices: UL2002, UL2014, UL2020, UL2021, UL2023, UL2024, UL2030, UL2033, UL2034, UL2053 with 1.1.x firmwares.</label2><br><br>
<div class="container" style="display: flex; width: 100%;">
<div style="width: 50%; float: left; padding-left: 10px;">
    <label for="config_packet_list">Packet_payloads: </label>
    <select id="configKeysDropdown"></select>
    <label for="payload_raw">Payload: </label><br>
    <textarea id="payload_raw" cols=100 rows=20></textarea><br><br>
    <br><br>
    <div id="hexandfport">
      <label for="fport">Fport: </label>
      <div id="fPort" style="display: inline-block;"></div>
      <label for="hexValue" style="margin-left: 20px">Hex: </label>
      <div id="hexValue" style="display: inline-block;"></div>
      <br><br>
    </div>
    <label for="warnings">Warnings: </label>
    <div id="warning"></div><br>
    <label for="errors">Errors: </label>
    <div id="error"></div>
  </div>
  <div style="width: 50%; float: right; padding-left: 10px;">
    <br>
    <pre><code id="payload_strick"></code></pre>
  </div>
</div>
<div class="footer">Generated at 2024-06-12T09:11:08.772Z</div>
<script>
/// CODEC JAVASCRIPT STARTS FROM HERE

function BitPack(err) {
  // BINARY PACKING UTILITIES - Many workarounds here are only because
  // Dataview and other newer features are not available in ES5 (required by chirpstack).
  // basically a class (which is not directly supported in ES5)
  this.data_byte = 0;
  this.offset = 0; // 0 - 7
  this.err = err;
}

BitPack.prototype.addBit = function (val, key) {
  if (typeof val === 'string') {
    val = val.toLowerCase();
  }
  var val_int = parseInt(val);
  if (val === "true" || val === true || val_int === 1) {
    var val_bool = true;
  }
  else if (val === "false" || val === false || val_int === 0) {
    var val_bool = false;
  }
  else {
    var val_bool = false;
    this.err.warnings.push(key + " invalid_boolean_value_or_key_not_found");
  }

  if (this.offset + 1 >= 8) {
    this.err.errors.push(key + " too_many_bits");
  }

  this.data_byte |= val_bool << this.offset;
  this.offset += 1;
};

BitPack.prototype.addBits = function (val, lengthBits, key) {
  val = parseInt(val);
  if (val === null) // TODO
  {
    this.err.warnings.push(key + " invalid_bits");
  }
  if (this.offset + lengthBits > 8) {
    this.err.errors.push(key + " too_many_bits");
  }

  var mask = Math.pow(2, lengthBits) - 1;

  // eslint-disable-next-line no-bitwise
  this.data_byte |= (val & mask) << this.offset;
  this.offset += lengthBits;
};


function BinaryPack(err) {
  // everything is little-endian for now
  this.buffer = [];
  this.err = err;
}

BinaryPack.prototype.length = function () {
  return this.buffer.length;
};

BinaryPack.prototype.int_invalid = function (val, val_int, val_min, val_max, key) {
  if (val === undefined) {
    this.err.warnings.push(key + " key_not_found");
    return true;
  }
  if (isNaN(val_int)) {
    this.err.warnings.push(key + " value_not_integer");
    return true;
  }
  if (val_int < val_min) {
    this.err.warnings.push(key + " value_too_small");
    return true;
  }
  if (val_int > val_max) {
    this.err.warnings.push(key + " value_too_large");
    return true;
  }
  return false;
};

BinaryPack.prototype.addFloat = function (val, key) {
  var value = parseFloat(val);
  if (isNaN(value)) {
    this.err.warnings.push(key + " value_not_integer");
    return true;
  }

  var bytes = 0;
  switch (value) {
    case Number.POSITIVE_INFINITY: bytes = 0x7F800000; break;
    case Number.NEGATIVE_INFINITY: bytes = 0xFF800000; break;
    case +0.0: bytes = 0x40000000; break;
    case -0.0: bytes = 0xC0000000; break;
    default:
      if (Number.isNaN(value)) { bytes = 0x7FC00000; break; }

      if (value <= -0.0) {
        bytes = 0x80000000;
        value = -value;
      }

      var exponent = Math.floor(Math.log(value) / Math.log(2));
      var significand = ((value / Math.pow(2, exponent)) * 0x00800000) | 0;

      exponent += 127;
      if (exponent >= 0xFF) {
        exponent = 0xFF;
        significand = 0;
      } else if (exponent < 0) exponent = 0;

      bytes = bytes | (exponent << 23);
      bytes = bytes | (significand & ~(-1 << 23));
      break;
  }
  this.addInt32(bytes, key);
};

BinaryPack.prototype.addUint8Arr = function (val) {
  for (var c = 0; c < val.length; c += 2)
    this.buffer.push(parseInt(val.substr(c, 2), 16));
};

BinaryPack.prototype.addUint8 = function (val, key) {
  var val_int = parseInt(val);
  if (this.int_invalid(val, val_int, 0, 255, key)) {
    this.buffer.push(0);
    return;
  }
  this.buffer.push(val_int);
};

BinaryPack.prototype.addInt8 = function (val, key) {
  var val_int = parseInt(val);
  if (this.int_invalid(val, val_int, -128, 127, key)) {
    this.buffer.push(0);
    return;
  }
  this.buffer.push(val_int >= 0 ? val_int : 0x100 + val_int);
};

BinaryPack.prototype.addUint16 = function (val, key) {
  var val_int = parseInt(val.toString(2).slice(-16), 2);
  if (this.int_invalid(val, val_int, 0, 65535, key)) {
    this.buffer.push(0);
    this.buffer.push(0);
    return;
  }
  this.buffer.push(val_int & 0xFF);
  this.buffer.push((val_int >> 8) & 0xFF);
};

BinaryPack.prototype.addInt16 = function (val, key) {
  var val_int = parseInt(val);
  if (this.int_invalid(val, val_int, -32768, 32767, key)) {
    this.buffer.push(0);
    this.buffer.push(0);
    return;
  }
  var pos_val = val_int >= 0 ? val_int : 0x10000 + val_int;
  this.buffer.push(pos_val & 0xFF);
  this.buffer.push((pos_val >> 8) & 0xFF);
};

BinaryPack.prototype.addUint32 = function (val, key) {
  var val_int = parseInt(val);
  if (this.int_invalid(val, val_int, 0, 4294967295, key)) {
    this.buffer.push(0);
    this.buffer.push(0);
    this.buffer.push(0);
    this.buffer.push(0);
    return;
  }
  this.buffer.push(val_int & 0xFF);
  this.buffer.push((val_int >> 8) & 0xFF);
  this.buffer.push((val_int >> 16) & 0xFF);
  this.buffer.push((val_int >> 24) & 0xFF);
};

BinaryPack.prototype.addInt32 = function (val, key) {
  var val_int = parseInt(val);
  if (this.int_invalid(val, val_int, -2147483648, 2147483647, key)) {
    this.buffer.push(0);
    this.buffer.push(0);
    this.buffer.push(0);
    this.buffer.push(0);
    return;
  }
  var pos_val = val_int >= 0 ? val_int : 0x100000000 + val_int;
  this.buffer.push(pos_val & 0xFF);
  this.buffer.push((pos_val >> 8) & 0xFF);
  this.buffer.push((pos_val >> 16) & 0xFF);
  this.buffer.push((pos_val >> 24) & 0xFF);
};

function strLookup(val, lookup, err)
{
    if (typeof val !== 'string')
    {
        return val;        
    }
    for (var key in lookup)
    {
        if (key.toLowerCase() === val.toLowerCase())
        {
            return lookup[key];
        }
    }
    if (isNaN(parseFloat(val)))
    {
        err.warnings.push("invalid_value " + val);
    }
    return val;
}

function addressEncode(addr_in, err) {
    var addr_int = parseInt(addr_in.replace(/\D/g,''));
    // if (!isNaN(addr_int)) {
    //     return addr_int;} 
    if (addr_in === 'analog_0_10v') {
      return 0x01;
    } if (addr_in === 'dali_broadcast') {
        return 0xFE;
    } if (addr_in === 'all_devices') {
        return 0xFF;
    } if (addr_in.toLowerCase().indexOf('dali_group_') !== -1) {
        return ((addr_int * 2) + 128);
    } if (addr_in.toLowerCase().indexOf('dali_single_') !== -1) {
        return (addr_int * 2);
    } if (addr_in.toLowerCase().indexOf('invalid') !== -1) {
        err.warnings.push("invaid_address "+addr_in);
        return 'invaid_address'
    }
}

function dimLevelEncode(level, err)
{
    if (level === "disabled") {
        return 0xff;
    }
    var l_int = parseInt(level);
    if (isNaN(l_int))
    {
        err.warnings.push("invalid_dim_value " + level);
        return 0xFF;
    }
    if (l_int < 0 || l_int > 100) {
        err.warnings.push("out_of_range_dim_value " + level);
    }
    return l_int
}

function convert_unix(time){
    return new Date(time).getTime() / 1000;
}

function encode_deprecated_ldr_input_config(data, pack, err) {
    pack.addUint8(0x01);
    pack.addUint8(strLookup(data.ldr_off_threshold_high, {"disabled": 0xFF}, err), "ldr_off_threshold_high");
    pack.addUint8(strLookup(data.ldr_on_threshold_low, {"disabled": 0xFF}, err), "ldr_on_threshold_low");
    var bits1 = new BitPack(err);
    bits1.addBits(0, 2, "");
    bits1.addBit(data.trigger_alert_enabled, "trigger_alert_enabled");
    pack.addUint8(bits1.data_byte);
}

function zen_angle(raw){
    return Math.round((raw - 90) * 6);
}

function encode_deprecated_dig_input_config(data, pack, err){
    pack.addUint8(0x03);
    pack.addUint16(strLookup(data.light_on_duration__s, {'dig_input_disabled': 0xFFFF}, err), 'light_on_duration__s');
    var bits1 = new BitPack(data);
    bits1.addBit(0, '');
    bits1.addBit(data.signal_edge_rising, 'signal_edge_rising');
    bits1.addBit(data.trigger_alert_enabled, 'trigger_alert_enabled');
    pack.addUint8(bits1.data_byte);
    pack.addUint8(addressEncode(data.address, err));
    pack.addUint8(dimLevelEncode(data.dimming_level__percent, err), 'dimming_level__percent');
}

function status_config(data, pack, err){
    pack.addUint8(0x07);
    var interval = parseInt(data.status_interval__s);
    if (interval < 60){
        err.warnings.push('status_interval_60s_minimum');
        pack.addUint32(60);
    } else if (interval > 86400){
        err.warnings.push('status_interval_86400s_maximum');
        pack.addUint8(86400);
    } else {
        pack.addUint32(interval, 'status_interval__s');
    }
}

function usage_config(data, pack, err){
    pack.addUint8(0x0B);
    var usage = strLookup(data.usage_interval__s, {'disabled': 0}, err);
    pack.addUint32(usage, 'usage_interval__s');
    if (data.mains_voltage__v){
        pack.addUint8(data.mains_voltage__v, mains_voltage__v);
    } else {
        pack.addUint8(0xFF);
    }
}

function time_config(data, pack, err){
    pack.addUint8(0x09);
    var time = strLookup(data.device_unix_epoch, {'force_lorawan_devicetimereq': 0}, err);
    pack.addUint32(convert_unix(time), 'device_unix_epoch');
}

function boot_delay_config(data, pack, err){
    pack.addUint8(0x0D);
    pack.addUint16(data.boot_delay_range__s);
}

function onboard_led_config(data, pack, err){
    pack.addUint8(0x15);
    var bits = new BitPack(err);
    bits.addBit(data.status_led_enabled, 'status_led_enabled');
    pack.addUint8(bits.data_byte);
}

function metering_alert_config(data, pack, err){
    pack.addUint8(0x16);
    pack.addUint8(0x01);
    pack.addUint16(strLookup(data.min_power__W, {'alert_off': 0xFFFF}, err), 'min_power__W');
    pack.addUint16(strLookup(data.max_power__W, {'alert_off': 0xFFFF}, err), 'max_power__W');
    pack.addUint16(strLookup(data.min_voltage__V, {'alert_off': 0xFFFF}, err), 'min_voltage__V');
    pack.addUint16(strLookup(data.max_voltage__V, {'alert_off': 0xFFFF}, err), 'max_voltage__V');
    pack.addUint8(strLookup(data.min_power_factor, {'alert_off': 0xFF}, err), 'min_power_factor');
}

function encode_calendar_config(data, pack, err){
    pack.addUint8(0x20);

    var bits1 = new BitPack(err);
    bits1.addBits(data.sunrise_steps.length, 4, 'sunrise_step_length');
    bits1.addBits(data.sunset_steps.length, 4, 'sunset_step_length');
    pack.addUint8(bits1.data_byte);

    var bits2 = new BitPack(err);
    bits2.addBit(data.calendar_prefers_meta_pos, 'calendar_prefers_meta_pos');
    bits2.addBit(data.calendar_clamps_profiles, 'calendar_clamps_profiles');
    bits2.addBit(data.calendar_clamps_dig, 'calendar_clamps_dig');
    pack.addUint8(bits2.data_byte);

    pack.addInt16(data.latitude__deg * 100, "latitude__deg");
    pack.addInt16(data.longitude__deg * 100, "longitude__deg");

    for (var step of data.sunrise_steps) {
        pack.addInt8(zen_angle(step.zenith_angle__deg), "zenith_angle__deg");
        pack.addUint8(strLookup(step.dimming_level__percent, {'disabled': 0xFF}, err), "dimming_level__percent");
    }
    for (var step of data.sunset_steps) {
        pack.addInt8(zen_angle(step.zenith_angle__deg), "zenith_angle__deg");
        pack.addUint8(strLookup(step.dimming_level__percent, {'disabled': 0xFF}, err), "dimming_level__percent");
    }
}

function day_shifts(day, err)
{
    switch (day)
    {
        case "holiday":
            return 0;
        case "mon":
            return 1;
        case "tue":
            return 2;
        case "wed":
            return 3;
        case "thu":
            return 4;
        case "fri":
            return 5;
        case "sat":
            return 6;
        case "sun":
            return 7;
        default:
            err.warnings.push("invalid_day " + day);
            return -1;
    }
}

function convertH2M(timeInHour){
    var timeParts = timeInHour.split(':');
    return parseInt(timeParts[0]) * 60 + parseInt(timeParts[1]);
}

function encode_profile_config(data, pack, err){
    pack.addUint8(0x21);

    pack.addUint8(data.profile_id, 'profile_id');
    pack.addUint8((data.dimming_steps.length < 10) ? data.dimming_steps.length : 'invalid', 'dimming_steps'); // !TODO
    pack.addUint8(addressEncode(data.address, err));

    var days = 0;
    for (var day of data.days_active)
        days |= 1 << day_shifts(day, err);
    pack.addUint8(days);
    pack.addUint8(0x00);

    for (var i = 0; i < data.dimming_steps.length; i++){
        pack.addUint8(convertH2M(data.dimming_steps[i].step_time) / 10, 'step_time_');
        pack.addUint8(strLookup(data.dimming_steps[i].dimming_level__percent, {'inactive': 0xFF}, err), 'dimming_level__percent_');
    }
}

function encode_fade(fade, err){
    if(fade === 'ignore'){
        return 0xFF;
    }else if(fade < 0.45 || fade > 90.53){
        err.warnings.push("invalid_value");
        return;
    }else {
        return Math.round(Math.log(fade) / Math.log(Math.sqrt (2))) + 2;
    }
}

function encode_fade_config(data, pack, err){
    pack.addUint8(0x22);
    pack.addUint8(encode_fade(data.fade_duration__s, err));
}

function convertMonth(data){
    var Month_Day = data.split('/');

    return {month: Month_Day[0],
            day: Month_Day[1]}
}

function encode_holiday_config(data, pack, err){
    pack.addUint8(0x23);
    pack.addUint8(data.holidays.length <10 ? data.holidays.length: 'invalid', 'holiday_length');

    for (var i = 0; i < data.holidays.length; i++){
        var Month_Day = convertMonth(data.holidays[i]);
        pack.addUint8(Month_Day.month, 'month');
        pack.addUint8(Month_Day.day, 'day');
    }
}

function encode_dali_monitor_config(data, pack, err){
    pack.addUint8(0x24);
    var bits1 = new BitPack(err);
    bits1.addBit(data.send_dali_alert, 'send_dali_alert');
    bits1.addBit(data.correct_dali_dimming_level, 'correct_dali_dimming_level');
    bits1.addBit(data.periodic_bus_scan_enabled, 'periodic_bus_scan_enabled');
    pack.addUint8(bits1.data_byte);
    pack.addUint16(strLookup(data.monitoring_interval__s, {'disabled': 0xFF}, err), 'monitoring_interval__s');
}

function fallback_dim_config(data, pack, err){
    pack.addUint8(0x25);
    pack.addUint8(data.fallback_dimming_level__percent, 'fallback_dimming_level__percent');
}

function utf8ToArr(val){
    var utf8 = [];

    for (var i = 0; i < val.length; i++) {
        var charCode = val.charCodeAt(i);

        if (charCode < 0x80) {
            utf8.push(charCode);
        } else if (charCode < 0x800) {
            utf8.push((charCode >> 6) | 0xC0, (charCode & 0x3F) | 0x80);
        } else if (charCode < 0x10000) {
            utf8.push((charCode >> 12) | 0xE0, ((charCode >> 6) & 0x3F) | 0x80, (charCode & 0x3F) | 0x80);
        } else if (charCode < 0x200000) {
            utf8.push((charCode >> 18) | 0xF0, ((charCode >> 12) & 0x3F) | 0x80, ((charCode >> 6) & 0x3F) | 0x80, (charCode & 0x3F) | 0x80);
        }
    }
    return utf8;
}

function location_config(data, pack, err){
    pack.addUint8(0x26);
    var enc_address = utf8ToArr(data.address);
    pack.addUint8(enc_address.length, 'address_length');
    pack.addUint32(strLookup(data.latitude__deg * 10000000, {'not_configured': 0x7FFFFFFF}, err), 'latitude__deg');
    pack.addUint32(strLookup(data.longitude__deg * 10000000, {'not_configured': 0x7FFFFFFF}, err), 'longitude__deg');
    for (var i = 0; i < enc_address.length; i++){
        pack.addUint8(enc_address[i]);
    }
}

function lumalink_decode(access_mode, err){
    switch(access_mode){
        case 'never_advertise':
            return 0x00;
        case 'first_commission':
            return 0x01;
        case 'every_boot':
            return 0x02;
        case 'always':
            return 0x03;
        default:
            err.warnings.push('invalid_lumalink_configuration');
            return -1;
    }
}

function lumalink_config(data, pack, err){
    pack.addUint8(0x27);
    pack.addUint8(lumalink_decode(data.access_mode, err));
}

function dig_input_config(data, pack, err){
    pack.addUint8(0x28);
    pack.addUint8(strLookup(data.dig_index, {'enable_dig': 0x00, 'disable_dig': 0xFF}), 'dig_index');

    var bits1 = new BitPack(err);
    bits1.addBit(data.dig_mode_button, 'dig_mode_button');
    bits1.addBit(data.polarity_high_or_rising, 'polarity_high_or_rising');
    bits1.addBit(data.alert_on_activation, 'alert_on_activation');
    bits1.addBit(data.alert_on_inactivation, 'alert_on_inactivation');
    pack.addUint8(bits1.data_byte);

    pack.addUint8(addressEncode(data.address, err), 'address');
    pack.addUint8(strLookup(data.active_dimming_level__percent, {'inactive': 0xFF}, err), 'active_dimming_level__percent');
    pack.addUint8(strLookup(data.inactive_dimming_level__percent, {'inactive': 0xFF}, err), 'inactive_dimming_level__percent');

    pack.addUint16(data.on_delay__s, 'on_delay__s');
    pack.addUint16(data.on_delay__s, 'on_delay__s');
}

function light_sensor_config(data, pack, err){
    pack.addUint8(0x29);
    pack.addUint8(strLookup(data.dim_steps.length, {'disabled': 0xFF}, err), 'step_count');

    var bits1 = new BitPack(err);
    bits1.addBit(data.notification_on_every_step, 'notification_on_every_step');
    bits1.addBit(data.light_sensor_clamps_profile, 'light_sensor_clamps_profile');
    bits1.addBit(data.light_sensor_clamps_dig, 'light_sensor_clamps_dig');
    bits1.addBit(data.interpolate_steps, 'interpolate_steps');
    pack.addUint8(bits1.data_byte);

    pack.addUint8(data.measurement_duration__s, 'measurement_duration__s');
    pack.addUint8(addressEncode(data.address, err), 'address');
    if (data.dim_steps != 'disabled'){
        for (var i=0; i < data.dim_steps.length; i++){
            pack.addFloat(data.dim_steps[i].light_level__lx, 'light_level__lx');
            pack.addUint8(strLookup(data.dim_steps[i].dimming_level__percent, {'inactive': 0xFF}, err), 'dimming_level__percent');
        }
    }
}

function dim_notify_config(data, pack, err){
    pack.addUint8(0x2A);
    pack.addUint8(strLookup(data.random_delay__s / 5, {'disabled': 0xFF}, err), 'random_delay__s');
    pack.addUint8((data.packet_limit__s / 60), 'packet_limit__s');
}

function interface_type_config(data, pack, err){
    pack.addUint8(0x2B);
    var lookup = {"dali":0, "analog_0_10v": 1, "factory_default": 255};
    pack.addUint8(lookup[data["interface_type"]], 'interface_type');
}

function multicast_config(data, pack, err){
    pack.addUint8(0x52);
    pack.addUint8(data.multicast_device, 'multicast_device');
    
    if (data.devaddr.length != 8) {
        err.warnings.push("invalid_devaddr_length");
    }
    pack.addUint32(parseInt(data.devaddr, 16), 'devaddr');

    if (data.nwkskey.length != 32) {
        err.warnings.push('invalid_nwkskey_length');
    }
    pack.addUint8Arr(data.nwkskey, 'nwkskey');

    if (data.appskey.length != 32) {
        err.warnings.push('invalid_appskey_length');
    }
    pack.addUint8Arr(data.appskey, 'appskey');
}

function encodeProfile(profile, err){
    switch(profile){
        case 'profile_0':
            return 0x00;
        case 'profile_1':
            return 0x01;
        case 'profile_2':
            return 0x02;
        case 'profile_3':
            return 0x03;
        case 'profile_4':
            return 0x04;
        case 'profile_5':
            return 0x05;
        case 'profile_6':
            return 0x06;
        case 'profile_7':
            return 0x07;
        case 'all_profiles':
            return 0xFF;
        default:
            err.warnings.push('unkown_profile');
            return 0xFF;  
    }
}

function encodeMulticast(multicast, err){
    switch(multicast){
        case 'multicast_device_0':
            return 0x00;
        case 'multicast_device_1':
            return 0x01;
        case 'multicast_device_2':
            return 0x02;
        case 'multicast_device_3':
            return 0x03;
        case 'all_multicast_devices':
            return 0xFF;
        default:
            err.warnings.push('invalid_multicast_device');
            return 0xFF;
    }
}

function clear_config(data, pack, err){
    pack.addUint8(0xFF);
    switch(data.reset_target){
        case 'light_sensor_config':
            pack.addUint8(0x29);
            break;
        case 'dig_input_config':
            pack.addUint8(0x28);
            break;
        case 'profile_config':
            pack.addUint8(0x21);
            pack.addUint8(encodeProfile(data.address, err), 'profile_id');
            break;
        case 'holiday_config':
            pack.addUint8(0x23);
            break;
        case 'multicast_config':
            pack.addUint8(0x52);
            pack.addUint8(encodeMulticast(data.multicast_device, err), 'multicast_device');
            break;
        case 'factory_reset':
            pack.addUint8(0xFF);
            pack.addUint32(parseInt(data.device_serial, 16), 'device_serial');
            break;
        default:
            err.warnings.push('invalid_target');
            break;
    }
}

function encode_conf_requests(data, pack, err){
    switch(data.packet_type){
        case 'ldr_input_config_request':
            pack.addUint8(0x01);
            break;
        case 'dig_input_config_request':
            pack.addUint8(0x03);
            break;
        case 'status_config_request':
            pack.addUint8(0x07);
            break;
        case 'time_config_request':
            pack.addUint8(0x09);
            break;
        case 'usage_config_request':
            pack.addUint8(0x0B);
            break;
        case 'boot_delay_config_request':
            pack.addUint8(0x0D);
            break;
        case 'onboard_led_config_request':
            pack.addUint8(0x15);
            break;
        case 'metering_alert_config_request':
            pack.addUint8(0x16);
            break;
        case 'calendar_config_request':
            pack.addUint8(0x20);
            break;
        case 'profile_config_request':
            pack.addUint8(0x21);
            pack.addUint8(encodeProfile(data.profile_id, err), 'profile_id');
            break;
        case 'fade_config_request':
            pack.addUint8(0x22);
            break;
        case 'holiday_config_request':
            pack.addUint8(0x23);
            break;
        case 'dali_monitor_config_request':
            pack.addUint8(0x24);
            break;
        case 'fallback_dim_config_request':
            pack.addUint8(0x25);
            break;
        case 'location_config_request':
            pack.addUint8(0x26);
            break;
        case 'lumalink_config_request':
            pack.addUint8(0x27);
            break;
        case 'dig_input_config_request':
            pack.addUint8(0x28);
            break;
        case 'light_sensor_config_request':
            pack.addUint8(0x29);
            break;
        case 'dim_notify_config_request':
            pack.addUint8(0x2A);
            break;
        case 'multicast_config_request':
            pack.addUint8(0x52);
            pack.addUint8(data.multicast_device, 'multicast_device');
            break;
        default:
            err.warnings.push('invalid_request_packet');
            break;   
    }
}

function pack_address_dim_level(dest, pack, err) {
    pack.addUint8(addressEncode(dest.address));
    var dim = strLookup(dest.dimming_level__percent, {'resume': 0xFF}, err);
    pack.addUint8(dim, 'dimming_level__percent');
}

function manual_dimming(data, pack, err){
    pack.addUint8(0x01);
    for (var i = 0;i < data.destination.length; i++){
        pack_address_dim_level(data.destination[i], pack, err);
    }
}

function manual_timed_dimming(data, pack ,err){
    pack.addUint8(0x09);
    for (var i = 0; i<data.destination.length; i++){
        pack_address_dim_level(data.destination[i], pack, err);
        pack.addUint8(data.destination[i].duration__minutes, 'duration__minutes');
    }
}

function status_usage_request(data, pack, err){
    pack.addUint8(0x05);
    if (data.dim_map_report_requested) {
        for (var i = 0; i<data.drivers.length; i++){
            pack.addUint8(0x04);
            pack.addUint8(addressEncode(data.drivers[i].address, err), 'dali_driver');
            pack.addUint8(data.drivers[i].dali_min_level, 'dali_min_level');
            pack.addUint8(data.drivers[i].dali_max_level, 'dali_max_level');
            var curve = strLookup(data.drivers[i].dimming_curve, {'logarithmic': 0x00, 'linear':0x01}, err);
            pack.addUint8(curve, 'dimming_curve');
        }
    } else {
        var bits1 = new BitPack(err);
        bits1.addBit(data.usage_requested, 'usage_requested');
        bits1.addBit(data.status_requested, 'status_requested');
        pack.addUint8(bits1.data_byte);
    }
}

function open_drain_ouptut_control(data, pack, err){
    pack.addUint8(0x0C);
    var bits1 = new BitPack(err);
    bits1.addBit(data.open_drain_output_on, 'open_drain_output_on');
    pack.addUint8(bits1.data_byte);
}

function custom_dali_request(data, pack, err){
    pack.addUint8(0x03);
    pack.addUint8Arr(data.query_data_raw);
}

function custom_dali_command(data, pack, err){
    pack.addUint8(0x04);
    pack.addUint8Arr(data.dali_command);
}

function driver_memory_read(data, pack, err){
    pack.addUint8(0x07);
    pack.addUint8(addressEncode(data.address, err), 'address');
    pack.addUint8(data.memory_bank, 'memory_bank');
    pack.addUint8(data.memory_address, 'memory_address');
    pack.addUint8(data.read_size__bytes, 'read_size__bytes');
}

function driver_memory_write(data, pack, err){
    pack.addUint8(0x08);
    pack.addUint8(addressEncode(data.address, err), 'address');
    pack.addUint8(data.memory_bank, 'memory_bank');
    pack.addUint8(data.memory_address, 'memory_address');
}

function address_dali_driver(data, pack, err){
    pack.addUint8(0x0A);
    pack.addUint8(addressEncode(data.address, err), 'address');
}

function encode_packet(data, pack, err) {
    var fport = 50;
    if (data.packet_type === 'deprecated_ldr_input_config_packet') {
        encode_deprecated_ldr_input_config(data, pack, err);
    } else if (data.packet_type === 'deprecated_dig_input_config_packet') {
        encode_deprecated_dig_input_config(data, pack, err);
    } else if (data.packet_type === 'status_config_packet') {
        status_config(data, pack, err);
    } else if (data.packet_type === 'time_config_packet'){
        time_config(data, pack, err);
    } else if (data.packet_type === 'usage_config_packet'){
        usage_config(data, pack, err);
    } else if (data.packet_type === 'boot_delay_config_packet'){
        boot_delay_config(data, pack);
    } else if (data.packet_type === 'onboard_led_config_packet'){
        onboard_led_config(data, pack, err);
    } else if (data.packet_type === 'metering_alert_config_packet'){
        metering_alert_config(data, pack, err);
    } else if (data.packet_type === 'calendar_config_packet'){
        encode_calendar_config(data, pack, err);
    } else if (data.packet_type === 'profile_config_packet'){
        encode_profile_config(data, pack, err);
    } else if (data.packet_type === 'fade_config_packet'){
        encode_fade_config(data, pack, err);
    } else if (data.packet_type === 'holiday_config_packet'){
        encode_holiday_config(data, pack);
    } else if (data.packet_type === 'dali_monitor_config_packet'){
        encode_dali_monitor_config(data, pack, err);
    } else if (data.packet_type === 'fallback_dim_config_packet'){
        fallback_dim_config(data, pack);
    } else if (data.packet_type === 'location_config_packet'){
        location_config(data, pack, err);
    } else if (data.packet_type === 'lumalink_config_packet'){
        lumalink_config(data, pack, err);
    } else if (data.packet_type === 'dig_input_config_packet'){
        dig_input_config(data, pack, err);
    } else if (data.packet_type === 'light_sensor_config_packet'){
        light_sensor_config(data, pack, err);
    } else if (data.packet_type === 'dim_notify_config_packet'){
        dim_notify_config(data, pack, err);
    } else if (data.packet_type === 'interface_type_config_packet'){
        interface_type_config(data, pack);
    } else if (data.packet_type === 'multicast_config_packet'){
        multicast_config(data, pack, err);
    } else if (data.packet_type === 'clear_config_packet'){
        clear_config(data, pack, err);
    } else if (data.packet_type === 'chained_config_packet'){
        pack.addUint8(0xFE);
        for (var i = 0;i < data.payloads.length; i++){
            var fp = encode_packet(data.payloads[i], pack, err);
            if (fp == 0) {
                err.warnings.push("invalid_chained_payload " + data.payloads[i].packet_type);
            }
            if (fp != 50) {
                err.warnings.push("non_config_packet_in_chain " + data.payloads[i].packet_type);
            }
        }
    } else if (data.packet_type === 'activate_dfu_command'){
        pack.addUint8(0xFF);
        fport = 51;
    } else if (data.packet_type === 'restart_controller_command'){
        pack.addUint8(0xFE);
        fport = 51;
    } else if (data.packet_type === 'manual_dimming'){
        manual_dimming(data, pack, err);
        fport = 60;
    } else if (data.packet_type === 'manual_timed_dimming'){
        manual_timed_dimming(data, pack, err);
        fport = 60;
    } else if (data.packet_type === 'status_usage_request'){
        status_usage_request(data, pack, err);
        fport = 60;
    } else if (data.packet_type === 'open_drain_output_control'){
        open_drain_ouptut_control(data, pack, err);
        fport = 60;
    } else if (data.packet_type === 'custom_dali_request'){
        custom_dali_request(data, pack);
        fport = 60;
    } else if (data.packet_type === 'custom_dali_command'){
        custom_dali_command(data, pack);
        fport = 60;
    } else if (data.packet_type === 'driver_memory_read'){
        driver_memory_read(data, pack, err);
        fport = 60;
    } else if (data.packet_type === 'driver_memory_write'){
        driver_memory_write(data, pack, err);
        fport = 60;
    } else if (data.packet_type === 'address_dali_driver'){
        address_dali_driver(data, pack, err);
        fport = 60;
    } else if (data.packet_type === 'dali_identify'){
        pack.addUint8(0x0B);
        fport = 60;
    }
    else if (data.packet_type.indexOf('_request') !== -1){
        encode_conf_requests(data, pack, err);
        fport = 49;
    }
    else {
        err.warnings.push("invalid_packet_type "+ data.packet_type);
        fport = 0;
    }
    return fport;
}

function rawEncode(data){
    var err = {errors:[], warnings:[]};
    var pack = new BinaryPack(err);
    var fport = 0;
    var jdata = data.data;
    if ("data" in jdata) {
        jdata = jdata.data;
    }

    try{
        var fport = encode_packet(jdata, pack, err);
    } catch (error) {
        err.errors.push("encoder_error " + error.message);
    }
        
    return {bytes: pack.buffer, fPort: fport, warnings: err.warnings, errors: err.errors};
}

// You need only one entrypoint, others can be removed.

// entry point for TTN new api
function encodeDownlink(input) {
  return rawEncode(input);
}


var config_packet_list = {
    'status_config_packet':{"data": {
        "packet_type": "status_config_packet",
        "status_interval__s": 600
      }},
    'time_config_packet':{"data": {
        "packet_type": "time_config_packet",
        "device_unix_epoch": "2020-01-16T15:23:31.000Z"
      }},
    'usage_config_packet':{"data": {
        "packet_type": "usage_config_packet",
        "usage_interval__s": 900
      }},
    'boot_delay_config_packet':{
      "data": {
        "packet_type": "boot_delay_config_packet",
        "boot_delay_range__s": 120
      }},
    'onboard_led_config_packet': {
      "data": {
        "packet_type": "onboard_led_config_packet",
        "status_led_enabled": false
      }},
    'metering_alert_config_packet': {"data": {
      "packet_type": "metering_alert_config_packet",
      "min_power__W": 5,
      "max_power__W": "alert_off",
      "min_voltage__V": 190,
      "max_voltage__V": "alert_off",
      "min_power_factor": "alert_off"
    }},
    'calendar_config_packet': {"data": {
      "packet_type": "calendar_config_packet",
      "calendar_prefers_meta_pos": false,
      "calendar_clamps_profiles": false,
      "calendar_clamps_dig": false,
      "latitude__deg": 48.77,
      "longitude__deg": 13.84,
      "sunrise_steps": [
        {
          "zenith_angle__deg": "90.83",
          "dimming_level__percent": 0
        }
      ],
      "sunset_steps": [
        {
          "zenith_angle__deg": "89.67",
          "dimming_level__percent": 25
        }
      ]
    }},
    'profile_config_packet': {"data": {
      "packet_type": "profile_config_packet",
      "profile_id": 0,
      "address": "dali_broadcast",
      "days_active": [
        "mon",
        "tue",
        "wed",
        "thu",
        "fri"
      ],
      "dimming_steps": [
        {
          "step_time": "01:00",
          "dimming_level__percent": 20
        },
        {
          "step_time": "05:30",
          "dimming_level__percent": "inactive"
        }
      ]
    }},
    'fade_config_packet': {"data": {
      "packet_type": "fade_config_packet",
      "fade_duration__s": 16
    }},
    'holiday_config_packet':{"data": {
      "packet_type": "holiday_config_packet",
      "holidays": [
        "05/01"
      ]
    }},
    'dali_monitor_config_packet': {"data": {
      "packet_type": "dali_monitor_config_packet",
      "send_dali_alert": false,
      "correct_dali_dimming_level": false,
      "periodic_bus_scan_enabled": false,
      "monitoring_interval__s": 0,
      "monitoring_interval": "disabled"
    }},
    'fallback_dim_config_packet': {"data": {
      "packet_type": "fallback_dim_config_packet",
      "fallback_dimming_level__percent": 80
    }},
    'location_config_packet': {"data": {
      "packet_type": "location_config_packet",
      "latitude__deg": 59.437022,
      "longitude__deg": 24.753536,
      "address": "Ööbiku Str. 2-16"
    }},
    'lumalink_config_packet': {"data": {
      "packet_type": "lumalink_config_packet",
      "access_mode": "always"
    }},
    'dig_input_config_packet':{"data": {
      "packet_type": "dig_input_config_packet",
      "dig_index": 1,
      "dig_mode_button": true,
      "polarity_high_or_rising": true,
      "alert_on_activation": false,
      "alert_on_inactivation": false,
      "address": "dali_broadcast",
      "active_dimming_level__percent": 100,
      "inactive_dimming_level__percent": "inactive",
      "on_delay__s": 0,
      "off_delay__s": 120
    }},
    'light_sensor_config_packet': {"data": {
      "packet_type": "light_sensor_config_packet",
      "notification_on_every_step": false,
      "light_sensor_clamps_profile": true,
      "light_sensor_clamps_dig": true,
      "interpolate_steps": true,
      "measurement_duration__s": 60,
      "address": "dali_broadcast",
      "dim_steps": [
        {
          "light_level__lx": "24.50",
          "dimming_level__percent": 60
        },
        {
          "light_level__lx": "123.4",
          "dimming_level__percent": "inactive"
        }
      ]
    }},
    'dim_notify_config_packet': {"data": {
      "packet_type": "dim_notify_config_packet",
      "random_delay__s": 90,
      "packet_limit__s": 300
    }},
    'multicast_config_packet': {"data": {
      "packet_type": "multicast_config_packet",
      "multicast_device": 0,
      "devaddr": "11223344",
      "nwkskey": "82840C7056429B143D21974557F93A53",
      "appskey": "82840C70C08494B931FE2FA6F8835C6A"
    }},
    'chained_config_packet': {"data": {
      "packet_type": "chained_config_packet",
      "payloads": [
        {
          "packet_type": "deprecated_ldr_input_config_packet",
          "ldr_off_threshold_high": 80,
          "ldr_on_threshold_low": 40,
          "trigger_alert_enabled": false
        },
        {
          "packet_type": "boot_delay_config_packet",
          "boot_delay_range__s": 600
        }
      ]
    }},
    'clear_config_packet': {"data": {
      "packet_type": "clear_config_packet",
      "reset_target": "holiday_config"
    }},
    'simple configuration requests': {"data": {
      "packet_type": "calendar_config_request"
    }},
    'activate_dfu_command': {"data": {
        "packet_type": "activate_dfu_command"
      }},
    'manual_dimming': {"data": {
      "packet_type": "manual_dimming",
      "destination": [
        {
          "address": "dali_broadcast",
          "dimming_level__percent": 100
        }
      ]
    }},
    'manual_timed_dimming': {"data": {
      "packet_type": "manual_timed_dimming",
      "destination": [
        {
          "address": "dali_broadcast",
          "dimming_level__percent": 100,
          "duration__minutes": 5
        }
      ]
    }},
    'status_usage_request': {"data": {
      "packet_type": "status_usage_request",
      "usage_requested": true,
      "status_requested": false
    }},
    'open_drain_output_control': {"data": {
      "packet_type": "open_drain_output_control",
      "open_drain_output_on": true
    }},
    'custom_dali_request': {"data": {
      "packet_type": "custom_dali_request",
      "query_data_raw": "48A1",
      "address": "dali_single_36",
      "dali_query": 161
    }},
    'custom_dali_command': {"data": {
      "packet_type": "custom_dali_command",
      "dali_command": "A300FF2DFF2D"
    }},
    'driver_memory_read': {"data": {
      "packet_type": "driver_memory_read",
      "address": "dali_single_2",
      "memory_bank": 0,
      "memory_address": 3,
      "read_size__bytes": 6
    }},
    'address_dali_driver': {"data": {
      "packet_type": "address_dali_driver",
      "address": "dali_single_9"
    }},
    'dali_identify': {"data": {
      "packet_type": "dali_identify"
    }},
    'deprecated_ldr_input_config_packet':{"data": {
      "packet_type": "deprecated_ldr_input_config_packet",
      "ldr_off_threshold_high": 80,
      "ldr_on_threshold_low": 40,
      "trigger_alert_enabled": false
    }},
    'deprecated_dig_input_config_packet': {"data": {
      "packet_type": "deprecated_dig_input_config_packet",
      "light_on_duration__s": 30,
      "signal_edge_rising": false,
      "trigger_alert_enabled": false,
      "address": "dali_broadcast",
      "dimming_level__percent": 100
    }},
    'deprecated_ldr_input_config_packet':{"data": {
      "packet_type": "deprecated_ldr_input_config_packet",
      "ldr_off_threshold_high": 80,
      "ldr_on_threshold_low": 40,
      "trigger_alert_enabled": false
    }},
    'deprecated_dig_input_config_packet': {"data": {
      "packet_type": "deprecated_dig_input_config_packet",
      "light_on_duration__s": 30,
      "signal_edge_rising": false,
      "trigger_alert_enabled": false,
      "address": "dali_broadcast",
      "dimming_level__percent": 100
    }},
  };function stringFromUTF8Array(data) {
  // from https://weblog.rogueamoeba.com/2017/02/27/javascript-correctly-converting-a-byte-array-to-a-utf-8-string/
  var extraByteMap = [1, 1, 1, 1, 2, 2, 3, 0];
  var count = data.length;
  var str = '';
  for (var index = 0; index < count;) {
    // eslint-disable-next-line no-plusplus
    var ch = data[index++];
    // eslint-disable-next-line no-bitwise
    if (ch & 0x80) {
      // eslint-disable-next-line no-bitwise
      var extra = extraByteMap[(ch >> 3) & 0x07];
      // eslint-disable-next-line no-bitwise
      if (!(ch & 0x40) || !extra || ((index + extra) > count)) {
        return null;
      }
      // eslint-disable-next-line no-bitwise
      ch &= (0x3F >> extra);
      for (; extra > 0; extra -= 1) {
        // eslint-disable-next-line no-plusplus
        var chx = data[index++];
        // eslint-disable-next-line no-bitwise
        if ((chx & 0xC0) !== 0x80) {
          return null;
        }
        // eslint-disable-next-line no-bitwise
        ch = (ch << 6) | (chx & 0x3F);
      }
    }
    str += String.fromCharCode(ch);
  }
  return str;
}

function BitExtract(dataByte) {
  // BINARY EXTRACTING UTILITIES - Many workarounds here are only because
  // Dataview and other newer features are not available in ES5 (required by chirpstack).
  // basically a class (which is not directly supported in ES5)
  this.data = dataByte;
  this.offset = 0;
}

BitExtract.prototype._assertOnRemainingLength = function (lengthBits) {
  if (lengthBits === 0) { throw Error('invalid zero length bit field'); }
  if (this.offset + lengthBits > 8) { throw Error('invalid number of bits extracted'); }
};

BitExtract.prototype.getBits = function (lengthBits) {
  this._assertOnRemainingLength(lengthBits);
  var mask = Math.pow(2, lengthBits) - 1;
  // eslint-disable-next-line no-bitwise
  var res = (this.data >> this.offset) & mask;
  this.offset += lengthBits;
  return lengthBits === 1 ? Boolean(res) : res;
};

function BinaryExtract(buffer) {
  // everything is little-endian for now
  this.buffer = buffer;
  this.offset = 0;
}

BinaryExtract.prototype.availableLen = function () {
  return this.buffer.length - this.offset;
};

BinaryExtract.prototype._assertOnRemainingLength = function (length) {
  if (length > this.availableLen()) { throw Error('invalid buffer length: too short'); }
};

BinaryExtract.prototype.getUint8 = function () {
  this._assertOnRemainingLength(1);
  // eslint-disable-next-line no-plusplus
  return this.buffer[this.offset++];
};

BinaryExtract.prototype.getInt8 = function () {
  var res = this.getUint8();
  return res > 0x7F ? res - 0x100 : res;
};

BinaryExtract.prototype.getUint16 = function () {
  this._assertOnRemainingLength(2);
  // eslint-disable-next-line no-plusplus
  var res = this.buffer[this.offset++] + this.buffer[this.offset++] * 256;
  return res;
};

BinaryExtract.prototype.getInt16 = function () {
  var res = this.getUint16();
  return res > 0x7FFF ? res - 0x10000 : res;
};

BinaryExtract.prototype.getUint24 = function () {
  this._assertOnRemainingLength(3);
  // eslint-disable-next-line no-plusplus
  var res = this.buffer[this.offset++] + this.buffer[this.offset++] * 256
    // eslint-disable-next-line no-plusplus
    + this.buffer[this.offset++] * 65536;
  return res;
};

BinaryExtract.prototype.getUint32 = function () {
  this._assertOnRemainingLength(4);
  // eslint-disable-next-line no-plusplus
  var res = this.buffer[this.offset++] + this.buffer[this.offset++] * 256
    // eslint-disable-next-line no-plusplus
    + this.buffer[this.offset++] * 65536 + this.buffer[this.offset++] * 16777216;
  return res;
};

BinaryExtract.prototype.getInt32 = function () {
  var res = this.getUint32();
  return res > 0x7FFFFFFF ? res - 0x100000000 : res;
};

BinaryExtract.prototype.getUint64 = function () {
  var first = this.getUint32();
  var second = this.getUint32();
  // since double can safely represent needed range,
  // its used MAX_SAFE_INTEGER → 9_007_199_254_740_991
  var res = first + second * 0x100000000;
  return res;
};

BinaryExtract.prototype.getTextUtf8 = function (len) {
  this._assertOnRemainingLength(len);
  var res = stringFromUTF8Array(this.buffer.slice(this.offset, this.offset + len));
  this.offset += len;
  return res;
};

BinaryExtract.prototype.getUint8Bits = function () {
  return new BitExtract(this.getUint8());
};

BinaryExtract.prototype.getRaw = function (len) {
  this._assertOnRemainingLength(len);
  var res = this.buffer.slice(this.offset, this.offset + len);
  this.offset += len;
  return res;
};

BinaryExtract.prototype.getFloat = function () {
  var bytes = this.getUint32();
  // from https://stackoverflow.com/a/16001019/12636611
  // eslint-disable-next-line no-bitwise
  var sign = (bytes & 0x80000000) ? -1 : 1;
  // eslint-disable-next-line no-bitwise
  var exponent = ((bytes >> 23) & 0xFF) - 127;
  // eslint-disable-next-line no-bitwise
  var significand = (bytes & ~(-1 << 23));

  if (exponent === 128) { return sign * ((significand) ? Number.NaN : Number.POSITIVE_INFINITY); }

  if (exponent === -127) {
    if (significand === 0) return sign * 0.0;
    exponent = -126;
    // eslint-disable-next-line no-bitwise
    significand /= (1 << 22);
  } else {
    // eslint-disable-next-line no-bitwise
    significand = (significand | (1 << 23)) / (1 << 23);
  }
  return sign * significand * Math.pow(2, exponent);
};

function pad(number, length) {
  var str = '' + number;
  while (str.length < length) {
    str = '0' + str;
  }
  return str;
}

function intToHexStr(int, len) {
  return pad(int.toString(16).toUpperCase(), len);
}

function bytesToHexStr(byteArr) {
  var res = '';
  for (var i = 0; i < byteArr.length; i += 1) {
    res += ('00' + byteArr[i].toString(16)).slice(-2).toUpperCase();
  }
  return res;
}

function profileReason(reason, err) {

  switch (reason) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return 'profile_' + reason;
    case 0x21:
      return 'calendar_day';
    case 0x22:
      return 'calendar_night';
    case 0x30:
    case 0x31:
    case 0x32:
    case 0x33:
    case 0x34:
    case 0x35:
    case 0x36:
    case 0x37:
    case 0x38:
    case 0x39:
    case 0x3A:
    case 0x3B:
    case 0x3C:
    case 0x3D:
    case 0x3E:
    case 0x3F:
      return 'calendar_dawn_step_' + (reason - 0x30);
    case 0x50:
    case 0x51:
    case 0x52:
    case 0x53:
    case 0x54:
    case 0x55:
    case 0x56:
    case 0x57:
    case 0x58:
    case 0x59:
    case 0x5A:
    case 0x5B:
    case 0x5C:
    case 0x5D:
    case 0x5E:
    case 0x5F:
      return 'calendar_dusk_step_' + (reason - 0x50);
    case 0x70:
      return 'dig_inactive';
    case 0x71:
      return 'dig_active';
    case 0x80:
    case 0x81:
    case 0x82:
    case 0x83:
    case 0x84:
    case 0x85:
    case 0x86:
    case 0x87:
        return 'light_monitor_step_' + (reason - 0x80);
    case 245:
      return 'relay_off';
      // eslint-disable-next-line no-duplicate-case
    case 248:
      return 'fallback_active';
    case 246:
      return 'driver_not_found';
    case 250:
      return 'ldr_input_active';
    case 252:
      return 'dig_input_active';
    case 253:
      return 'manual_active';
    case 255:
      err.errors.push('unknown_reason');
      return 'unknown';
    default:
      err.errors.push('invalid_reason');
      return 'invalid_reason';
  }
}

function addressParse(addr, ffStr, err) {
  if (addr === 0x01) {
    return 'analog_0_10v';
  }
  if (addr === 0xFE) {
    return 'dali_broadcast';
  }
  if (addr === 0xFF) {
    if (ffStr) {
      return ffStr;
    }
    err.warnings.push('invalid_address');
    return 'invalid';
  }
  // eslint-disable-next-line no-bitwise
  if (addr & 0x01) {
    err.warnings.push('invalid_address');
    return 'invalid';
  }
  // eslint-disable-next-line no-bitwise
  if (addr & 0x80) {
    // eslint-disable-next-line no-bitwise
    return 'dali_group_' + ((addr >> 1) & 0xF).toString();
  }

  // eslint-disable-next-line no-bitwise
  return 'dali_single_' + ((addr >> 1) & 0x3F).toString();
}

function profileParserPartial(dataView, profile, err) {
  var id = dataView.getUint8();
  profile.profile_id = id === 255 ? 'no_profile' : id;

  var length = 0;
  length = dataView.getUint8();

  var addr = dataView.getUint8();
  profile.address = addressParse(addr, "all_devices", err);

  var activeDays = dataView.getUint8();
  var bits = new BitExtract(activeDays);
  var days = [];
  if (bits.getBits(1)) {
    days.push('holiday');
  }
  if (bits.getBits(1)) {
    days.push('mon');
  }
  if (bits.getBits(1)) {
    days.push('tue');
  }
  if (bits.getBits(1)) {
    days.push('wed');
  }
  if (bits.getBits(1)) {
    days.push('thu');
  }
  if (bits.getBits(1)) {
    days.push('fri');
  }
  if (bits.getBits(1)) {
    days.push('sat');
  }
  if (bits.getBits(1)) {
    days.push('sun');
  }
  profile.days_active = days;

  dataView.getUint8();
  return length;
}

function decodeUnixEpoch(epoch, err) {
  var date = new Date(epoch * 1000);
  var epochFormatted = date.toISOString();
  if (epoch < 1420070400) { // 1 January 2015 00:00:00
    epochFormatted = 'invalid_timestamp';
    err.warnings.push('invalid_timestamp');
  }
  return epochFormatted;
}

function decodeLdrConfig(dataView, result) {
  result.packet_type = 'deprecated_ldr_input_config_packet';

  var high = dataView.getUint8();
  result.ldr_off_threshold_high = high === 0xFF ? 'disabled' : high;

  var low = dataView.getUint8();
  result.ldr_on_threshold_low = low === 0xFF ? 'disabled' : low;

  var behaviorBits = dataView.getUint8Bits();
  behaviorBits.getBits(2);
  result.trigger_alert_enabled = behaviorBits.getBits(1);
}
function decodeLightDimStep(dataView) {
  var res = {};
  var light = dataView.getFloat();
  var level = dataView.getUint8();
  res.light_level__lx = formatLightLx(light);
  res.dimming_level__percent = decodeDimmingLevel(level, 'inactive');
  return res;
}

function decodeLightSensorConfig(dataView, result, err) {
  result.packet_type = 'light_sensor_config_packet';

  if (dataView.getUint8() === 0xFF) {
    return;
  }
  var bits = dataView.getUint8Bits();
  result.notification_on_every_step = bits.getBits(1);
  result.light_sensor_clamps_profile = bits.getBits(1);
  result.light_sensor_clamps_dig = bits.getBits(1);
  result.interpolate_steps = bits.getBits(1);

  result.measurement_duration__s = dataView.getUint8();

  result.address = addressParse(dataView.getUint8(), "all_devices", err);

  result.dim_steps = [];
  while (dataView.availableLen()) {
    result.dim_steps.push(decodeLightDimStep(dataView));
  }
}

function decodeDimNotifyConfig(dataView, result, err) {
  result.packet_type = 'dim_notify_config_packet';
  var rdly = dataView.getUint8();
  result.random_delay__s = rdly === 0xff ? 'disabled' : rdly * 5;
  result.packet_limit__s = dataView.getUint8() * 60;
}

function decodeInterfaceType(val, err) {
  switch (val) {
    case 0:
      return 'dali';
    case 1:
      return 'analog_0_10v';
    case 254:
      err.errors.push('not_supported');
      return 'not_supported';
    case 254:
      return 'factory_default';
    default:
      err.errors.push('invalid_value');
      return 'invalid_value';
  }
}

function decodeInterfaceTypeConfig(dataView, result, err) {
  result.packet_type = 'interface_type_config_packet';
  result.interface_type = decodeInterfaceType(dataView.getUint8(), err);
}

function decodeDimmingLevel(level, ffName) {
  if (level === 0xFF) {
    return ffName;
  }
  return level;
}

function decodeDigConfig(dataView, result, err) {
  result.packet_type = 'deprecated_dig_input_config_packet';

  var time = dataView.getUint16();
  result.light_on_duration__s = time === 0xFFFF ? 'dig_input_disabled' : time;

  var behaviorBits = dataView.getUint8Bits();
  behaviorBits.getBits(1);
  result.signal_edge_rising = behaviorBits.getBits(1);
  result.trigger_alert_enabled = behaviorBits.getBits(1);

  result.address = addressParse(dataView.getUint8(), "all_devices", err);

  result.dimming_level__percent = decodeDimmingLevel(dataView.getUint8(), 'disabled');
}

function decodeDigInputConfigNew(dataView, result, err) {
  result.packet_type = 'dig_input_config_packet';

  var index = dataView.getUint8();
  if (index === 0xFF) {
    return;
  }

  var bits = dataView.getUint8Bits();
  result.dig_mode_button = bits.getBits(1);
  result.polarity_high_or_rising = bits.getBits(1);
  result.notification_on_activation = bits.getBits(1);
  result.notification_on_inactivation = bits.getBits(1);

  result.address = addressParse(dataView.getUint8(), "all_devices", err);

  result.active_dimming_level__percent = decodeDimmingLevel(dataView.getUint8(), 'inactive');
  result.inactive_dimming_level__percent = decodeDimmingLevel(dataView.getUint8(), 'inactive');

  var on_delay = dataView.getUint16();
  var off_delay = dataView.getUint16();
  result.on_delay__s = on_delay;
  result.off_delay__s = off_delay;
}

function decodeStepTime(inByte) {
  var minTotal = inByte * 10;
  var hour = Math.trunc(minTotal / 60);
  var mn = minTotal - hour * 60;
  return pad(hour, 2) + ':' + pad(mn, 2);
}

function decodeOdRelaySwStep(dataView) {
  var res = {};
  res.step_time = decodeStepTime(dataView.getUint8());

  var state = dataView.getUint8() !== 0;
  res.open_drain_output_on = state;
  return res;
}

function decodeZenithStep(dataView) {
  var step = {};
  step.zenith_angle__deg = (dataView.getInt8() / 6 + 90).toFixed(2);

  var dim = dataView.getUint8();
  step.dimming_level__percent = decodeDimmingLevel(dim, 'disabled');
  return step;
}

function decodeCalendarConfigV11(dataView, result) {
  result.packet_type = 'calendar_config_packet';

  var steps = dataView.getUint8Bits();
  var sunriseSteps = steps.getBits(4);
  var sunsetSteps = steps.getBits(4);

  var bits = dataView.getUint8Bits();
  result.calendar_prefers_meta_pos = bits.getBits(1);
  result.calendar_clamps_profiles = bits.getBits(1);
  result.calendar_clamps_dig = bits.getBits(1);

  result.latitude__deg = dataView.getInt16() / 100;
  result.longitude__deg = dataView.getInt16() / 100;

  result.sunrise_steps = [];
  result.sunset_steps = [];

  for (var i1 = 0; i1 < sunriseSteps; i1 += 1) {
    result.sunrise_steps.push(decodeZenithStep(dataView));
  }
  for (var i2 = 0; i2 < sunsetSteps; i2 += 1) {
    result.sunset_steps.push(decodeZenithStep(dataView));
  }
}

function decodeStatusConfig(dataView, result) {
  result.packet_type = 'status_config_packet';
  result.status_interval__s = dataView.getUint32();
}

function decodeDimmingStep(dataView) {
  var res = {};
  res.step_time = decodeStepTime(dataView.getUint8());

  res.dimming_level__percent = decodeDimmingLevel(dataView.getUint8(), 'inactive');
  return res;
}

function decodeProfileConfig(dataView, result, err) {
  result.packet_type = 'profile_config_packet';
  var len = profileParserPartial(dataView, result, err);
  result.dimming_steps = [];

  for (var i = 0; i < len; i += 1) {
    result.dimming_steps.push(decodeDimmingStep(dataView));
  }
}

function decodeTimeConfig(dataView, result, err) {
  result.packet_type = 'time_config_packet';

  var epoch = dataView.getUint32();
  if (epoch == 0) {
    result.device_unix_epoch = 'force_lorawan_devicetimereq';
  }
  else
  {
    result.device_unix_epoch = decodeUnixEpoch(epoch, err);
  }
}

function decodeUsageConfig(dataView, result) {
  result.packet_type = 'usage_config_packet';
  var interval = dataView.getUint32();
  var volt = dataView.getUint8();
  result.usage_interval__s = interval;
  if (volt !== 0xFF) {
    result.mains_voltage__V = volt;
  }
}

function decodeMonthDay(dataView) {
  // eslint-disable-next-line no-bitwise
  return pad(dataView.getUint8(), 2) + '/' + pad(dataView.getUint8(), 2);
}

function decodeHolidayConfig(dataView, result) {
  result.packet_type = 'holiday_config_packet';
  result.holidays = [];

  var len = dataView.getUint8();
  for (var i = 0; i < len; i += 1) {
    result.holidays.push(decodeMonthDay(dataView));
  }
}

function decodeDaliMonitorConfig(dataView, result) {
  var bits = dataView.getUint8Bits();
  result.packet_type = 'dali_monitor_config_packet';
  result.send_dali_alert = bits.getBits(1);
  result.correct_dali_dimming_level = bits.getBits(1);
  result.periodic_bus_scan_enabled = bits.getBits(1);

  var interval = dataView.getUint16();
  if (interval === 0) {
    result.monitoring_interval__s = 'disabled';
  } else {
    result.monitoring_interval__s = interval;
  }
}

function decodeFallbackDimConfig(dataView, result) {
  result.packet_type = 'fallback_dim_config_packet';
  result.fallback_dimming_level__percent = dataView.getUint8();
}

function decodeMulticastFcntConfig(dataView, result) {
  result.packet_type = 'multicast_fcnt_config_packet';
  result.multicast_device = dataView.getUint8();
  result.multicast_fcnt = dataView.getUint32();
}

function decodeBootDelayConfig(dataView, result) {
  result.packet_type = 'boot_delay_config_packet';
  var legacy = dataView.availableLen() === 1;
  var range = legacy ? dataView.getUint8() : dataView.getUint16();
  result.boot_delay_range__s = range;
}

function decodeFade(fade, err) {
  var lookup = [0.5, 0.71, 1.0, 1.41, 2.0, 2.83, 4.0, 5.66, 8.0, 11.31,
    16.0, 22.63, 32.0, 45.25, 64.0, 90.51];
  if (fade === 255) {
    return 'ignore';
  } else if (fade >= 16) {
    err.errors.push('invalid_fade');
    return 'invalid_fade';
  } else {
    return lookup[fade];
  }
}

function decodeLocationConfigV11(dataView, result) {
  result.packet_type = 'location_config_packet';

  var addressLen = dataView.getUint8();

  result.latitude__deg = dataView.getInt32() / 10000000.0;
  result.longitude__deg = dataView.getInt32() / 10000000.0;

  result.address = dataView.getTextUtf8(addressLen);
}

function decodeLumalinkMode(mode, err) {
  switch (mode) {
    case 0:
      return 'never_advertise';
    case 1:
      return 'first_commission';
    case 2:
      return 'every_boot';
    case 3:
      return 'always';
    default:
      err.errors.push('invalid_mode');
      return 'invalid_mode';
  }
}

function decodeLumalinkConfig(dataView, result, err) {
  result.packet_type = 'lumalink_config_packet';
  result.access_mode = decodeLumalinkMode(dataView.getUint8(), err);
}

function decodeLedConfig(dataView, result) {
  result.packet_type = 'onboard_led_config_packet';
  var l = dataView.getUint8Bits().getBits(1);
  result.status_led_enabled = l;
}

function alertParamConfig(value, naValue) {
  var val = value === naValue ? 'alert_off' : value;
  return val;
}

function decodeMeteringAlertConfig(dataView, result, err) {
  result.packet_type = 'metering_alert_config_packet';
  var header = dataView.getUint8();
  if (header !== 0x01) {
    err.errors.push('invalid_packet_type');
    return;
  }
  var minPower = dataView.getUint16();
  var maxPower = dataView.getUint16();
  var minVoltage = dataView.getUint16();
  var maxVoltage = dataView.getUint16();
  var minPf = dataView.getUint8();

  result.min_power__W = alertParamConfig(minPower, 0xFFFF);
  result.max_power__W = alertParamConfig(maxPower, 0xFFFF);
  result.min_voltage__V = alertParamConfig(minVoltage, 0xFFFF);
  result.max_voltage__V = alertParamConfig(maxVoltage, 0xFFFF);
  result.min_power_factor = minPf === 0xFF ? 'alert_off' : minPf / 100.0;
}

function decodeFadeConfig(dataView, result, err) {
  result.packet_type = 'fade_config_packet';
  result.fade_duration__s = decodeFade(dataView.getUint8(), err);
}

function decodeMulticastConfig(dataView, result, err) {
  result.packet_type = 'multicast_config_packet';
  var dev = dataView.getUint8();

  var invalidMc = dev > 3;
  if (invalidMc) {
    err.errors.push('invalid_multicast_device');
    return;
  }
  result.multicast_device = dev;
  result.devaddr = bytesToHexStr(dataView.getRaw(4).reverse());

  result.nwkskey = bytesToHexStr(dataView.getRaw(16));

  result.appskey = bytesToHexStr(dataView.getRaw(16));
}

function decodeClearConfig(dataView, result, err) {
  result.packet_type = 'clear_config_packet';
  switch (dataView.getUint8()) {
    case 0x21:
      result.reset_target = 'profile_config';
      result.address = addressParse(dataView.getUint8(), 'all_profiles', err);
      break;
    case 0x23:
      result.reset_target = 'holiday_config';
      break;
    case 0x28:
      result.reset_target = 'dig_input_config';
      break;
    case 0x29:
      result.reset_target = 'light_sensor_config';
      break;
    case 0x52:
      result.reset_target = 'multicast_config';
      var device = dataView.getUint8();
      result.multicast_device = device === 0xff ? 'all_multicast_devices' : 'multicast_device_' + device;
      break;
    case 0xFF:
      result.reset_target = 'factory_reset';
      result.device_serial = intToHexStr(dataView.getUint32(), 8);
      break;
    default:
      err.errors.push('invalid_clear_config_target');
  }
}

function decodeFport50(dataView, result, err) {
  var header = dataView.getUint8();
  switch (header) {
    case 0x01:
      decodeLdrConfig(dataView, result);
      return;
    case 0x03:
      decodeDigConfig(dataView, result, err);
      return;
    case 0x05:
      result.packet_type = 'open_drain_output_config_packet';
      result.switching_steps = [];
      while (dataView.availableLen()) {
        result.switching_steps.push(decodeOdRelaySwStep(dataView));
      }
      return;
    case 0x07:
      decodeStatusConfig(dataView, result);
      return;
    case 0x09:
      decodeTimeConfig(dataView, result, err);
      return;
    case 0x0B:
      decodeUsageConfig(dataView, result);
      return;
    case 0x0D:
      decodeBootDelayConfig(dataView, result);
      return;
    case 0x15:
      decodeLedConfig(dataView, result);
      return;
    case 0x16:
      decodeMeteringAlertConfig(dataView, result, err);
      return;
    case 0x52:
      decodeMulticastConfig(dataView, result, err);
      return;
    case 0xFF:
      decodeClearConfig(dataView, result, err);
      return;

    case 0x20:
      decodeCalendarConfigV11(dataView, result);
      return;
    case 0x21:
      decodeProfileConfig(dataView, result, err);
      return;
    case 0x22:
      decodeFadeConfig(dataView, result, err);
      return;
    case 0x23:
      decodeHolidayConfig(dataView, result);
      return;
    case 0x24:
      decodeDaliMonitorConfig(dataView, result);
      return;
    case 0x25:
      decodeFallbackDimConfig(dataView, result);
      return;
    case 0x26:
      decodeLocationConfigV11(dataView, result);
      return;
    case 0x27:
      decodeLumalinkConfig(dataView, result, err);
      return;
    case 0x28:
      decodeDigInputConfigNew(dataView, result, err);
      return;
    case 0x29:
      decodeLightSensorConfig(dataView, result, err);
      return;
    case 0x2A:
      decodeDimNotifyConfig(dataView, result);
      return;
    case 0x2B:
      decodeInterfaceTypeConfig(dataView, result, err);
      return;
    case 0x53:
      decodeMulticastFcntConfig(dataView, result);
      return;
    case 0xFE:
      result.packet_type = 'chained_config_packet';
      result.payloads = [];
      while (dataView.availableLen()) {
        var packet = {};
        decodeFport50(dataView, packet, err);
        result.payloads.push(packet);
      }
      return;
    default:
      err.errors.push('invalid_packet_type');
  }
}

function daliStatus(bits, address, err) {
  var status = {
    driver_error: false,
    lamp_failure: false,
    lamp_on: false,
    limit_error: false,
    fade_running: false,
    reset_state: false,
    missing_short_address: false,
    power_failure: false,
  };
  if (bits.data === 0xFF) return status;

  var driverError = bits.getBits(1);
  status.driver_error = driverError;

  var lampFailure = bits.getBits(1);
  status.lamp_failure = lampFailure;

  status.lamp_on = bits.getBits(1);

  var limitError = bits.getBits(1);
  status.limit_error = limitError;

  status.fade_running = bits.getBits(1);

  var resetState = bits.getBits(1);
  status.reset_state = resetState;

  var missingAddress = bits.getBits(1);
  status.missing_short_address = missingAddress;

  var powerFailure = bits.getBits(1);
  status.power_failure = powerFailure;

  if (driverError) err.warnings.push(address + ' driver_error');
  if (lampFailure) err.warnings.push(address + ' lamp_failure');
  if (limitError) err.warnings.push(address + ' limit_error');
  if (resetState) err.warnings.push(address + ' reset_state');
  if (powerFailure) err.warnings.push(address + ' power_failure');
  return status;
}

function decodeDaliStatus(dataView, err) {
  var result = {};
  var addr = dataView.getUint8();
  var addrParsed = addressParse(addr, null, err);
  result.address = addrParsed;

  result.status = daliStatus(dataView.getUint8Bits(), addrParsed, err);
  return result;
}

function decodeDimming(dataView, err) {
  var result = {};
  result.address = addressParse(dataView.getUint8(), "all_devices", err);

  result.dimming_level__percent = decodeDimmingLevel(dataView.getUint8(), 'resume');
  return result;
}

function decodeDimmingCommand(dataView, result, err) {
  result.packet_type = 'manual_dimming';
  result.destination = [];
  while (dataView.availableLen()) {
    result.destination.push(decodeDimming(dataView, err));
  }
}

function decodeCustomDaliReq(dataView, result, err) {
  result.packet_type = 'custom_dali_request';

  var offset = dataView.offset;
  result.query_data_raw = bytesToHexStr(dataView.getRaw(dataView.availableLen()));
  // restore previous offset like the getRaw read never happened
  dataView.offset = offset;

  // if lengt is 2 then address+query, 3 then address+query+asnwer.
  // If length is more, we cant assume anything, because we dont know if its uplink or downlink.
  if (dataView.availableLen() > 3) {
    dataView.getRaw(dataView.availableLen());
    return;
  }

  var addr = dataView.getUint8();
  result.address = addressParse(addr, null, err);

  result.dali_query = dataView.getUint8();

  if (dataView.availableLen() === 1) {
    result.dali_response = dataView.getUint8();
  }
}

function decodeCustomDaliCommand(dataView, result) {
  result.packet_type = 'custom_dali_command';
  result.dali_command = bytesToHexStr(dataView.getRaw(dataView.availableLen()));
}

function decodeDimMap(dataView, err) {
  var result = {};
  result.address = addressParse(dataView.getUint8(), null, err);
  result.dali_min_level = dataView.getUint8();
  result.dali_max_level = dataView.getUint8();
  result.dimming_curve = dataView.getUint8() === 0 ? 'logarithmic' : 'linear';
  return result;
}

function decodeStatusRequest(dataView, result, err) {
  result.packet_type = 'status_usage_request';

  var bits = dataView.getUint8Bits();
  result.usage_requested = bits.getBits(1);
  result.status_requested = bits.getBits(1);
  result.dim_map_report_requested = bits.getBits(1);

  if (result.dim_map_report_requested && dataView.availableLen() > 0) {
    result.drivers = [];
    while (dataView.availableLen()) {
      result.drivers.push(decodeDimMap(dataView, err));
    }
  }
}

function decodeDriverMemoryPartial(dataView, result, err) {
  result.address = addressParse(dataView.getUint8(), null, err);

  result.memory_bank = dataView.getUint8();
  result.memory_address = dataView.getUint8();}

function decodeDriverMemoryPartialSized(dataView, result, err) {
  decodeDriverMemoryPartial(dataView, result, err);
  var size = dataView.getUint8();
  result.read_size__bytes = size;
  return size;
}

function decodeReadDriverMemory(dataView, result, err) {
  result.packet_type = 'driver_memory_read';
  if (dataView.availableLen() === 0) {
    err.warnings.push('driver_memory_read_failed');
    return;
  }

  var size = decodeDriverMemoryPartialSized(dataView, result, err);
  if (dataView.availableLen()) {
    var data = dataView.getRaw(size);
    result.memory_value = bytesToHexStr(data);
  }
}

function decodeWriteDriverMemory(dataView, result, err) {
  result.packet_type = 'driver_memory_write';
  if (dataView.availableLen() === 0) {
    err.warnings.push('driver_memory_write_failed');
    return;
  }

  decodeDriverMemoryPartial(dataView, result);
  result.memory_value = bytesToHexStr(dataView.getRaw(dataView.availableLen()));
}

function decodeTimedDimming(dataView, err) {
  var result = {};
  result.address = addressParse(dataView.getUint8(), "all_devices", err);

  result.dimming_level__percent = decodeDimmingLevel(dataView.getUint8(), 'resume');

  result.duration__minutes = dataView.getUint8();
  return result;
}

function decodeTimedDimmingCommand(dataView, result, err) {
  result.packet_type = 'manual_timed_dimming';
  result.destination = [];
  while (dataView.availableLen()) {
    result.destination.push(decodeTimedDimming(dataView, err));
  }
}

function decodeAddressDaliDriver(dataView, result, err) {
  result.packet_type = 'address_dali_driver';
  result.address = addressParse(dataView.getUint8(), 'rescan_dali_bus', err);
}

function decodeDaliIdentify(result) {
  result.packet_type = 'dali_identify';
}

function decodeOpenDrainSwitching(dataView, result) {
  result.packet_type = 'open_drain_output_control';
  result.open_drain_output_on = dataView.getUint8Bits().getBits(1);
}

function decodeFport60(dataView, result, err) {
  var header = dataView.getUint8();
  switch (header) {
    case 0x01:
      decodeDimmingCommand(dataView, result, err);
      return;
    case 0x03:
      decodeCustomDaliReq(dataView, result, err);
      return;
    case 0x04:
      decodeCustomDaliCommand(dataView, result);
      return;
    case 0x05:
      decodeStatusRequest(dataView, result, err);
      return;
    case 0x07:
      decodeReadDriverMemory(dataView, result, err);
      return;
    case 0x08:
      decodeWriteDriverMemory(dataView, result, err);
      return;
    case 0x09:
      decodeTimedDimmingCommand(dataView, result, err);
      return;
    case 0x0C:
      decodeOpenDrainSwitching(dataView, result);
      return;

    case 0x0A:
      decodeAddressDaliDriver(dataView, result, err);
      return;
    case 0x0B:
      decodeDaliIdentify(result);
      return;

    default:
      err.errors.push('invalid_command');
  }
}

function dimmingSourceParser(dataView, err) {
  var source = {};

  source.address = addressParse(dataView.getUint8(), null, err);
  source.reason = profileReason(dataView.getUint8(), err);
  source.dimming_level__percent = decodeDimmingLevel(dataView.getUint8(), 'n/a');
  source.status = daliStatus(dataView.getUint8Bits(), source.address, err);
  return source;
}

function formatLightLx(lx) {
  var log10_val = Math.log10(lx);
  var log10_pos = log10_val >= 0 ? log10_val : 0;
  var log10_lim = log10_pos > 3 ? 3 : log10_pos;
  var decimals = 3 - Math.trunc(log10_lim);
  return lx.toFixed(decimals);
}

function calcLightLx(light_raw) {
  if (light_raw === 0xFFFF) {
    return 'unavailable'
  }
  var light_val = light_raw & 0x7FFF;
  var lx = Math.pow(10, light_val / 4000.0) / 1000.0;
  return formatLightLx(lx);
}

function decodeSensorSource(dataView, header, result, err) {
  if (header === 0x01) {
    result.sensor_source.ldr_input = dataView.getUint8();
    return 1;
  }
  if (header == 0x02) {
    result.sensor_source.light_sensor__lx = calcLightLx(dataView.getUint16());
    return 2;
  }
  if (header == 0x03) {
    result.sensor_source.d4i_light_sensor__lx = calcLightLx(dataView.getUint16());
    return 2;
  }
  if (header == 0x04) {
    var bits = dataView.getUint8Bits();
    result.sensor_source.dig_input_1_on = bits.getBits(1);
    return 1;
  }
  if (header == 0x08) {
    var deg = dataView.getUint8();
    if (deg == 0xFF) {
      deg = null;
    }
    result.sensor_source.tilt_sensor__deg = deg;
    return 1;
  }
  return 0;
}

function statusParser1_1(dataView, result, err) {
  result.packet_type = 'status_packet';

  var header = dataView.getUint8();
  var header_below_1_1_4 = header === 0x00;
  if (!header_below_1_1_4 && header !== 0x01) {
    err.errors.push('invalid_packet_type');
    return;
  }

  var epoch = dataView.getUint32();
  result.device_unix_epoch = decodeUnixEpoch(epoch, err);

  var statusField = {};
  var bits = dataView.getUint8Bits();

  bits.getBits(1);
  var daliErrConn = bits.getBits(1);
  var ldrOn = bits.getBits(1);
  bits.getBits(1);
  var digOn = bits.getBits(1);
  var err1 = bits.getBits(1);
  var err2 = bits.getBits(1);
  var internalRelay = bits.getBits(1);

  statusField.dali_connection_error = daliErrConn;
  if (daliErrConn) err.warnings.push('dali_connection_error');

  statusField.metering_com_error = err1;
  if (err1) err.warnings.push('metering_com_error');

  statusField.ext_rtc_warning = err2;
  if (err2) err.warnings.push('ext_rtc_warning');

  statusField.internal_relay_closed = internalRelay;
  if (header_below_1_1_4) {
    statusField.ldr_input_on = ldrOn;
    statusField.dig_input_on = digOn;
  }

  if (!header_below_1_1_4) {
    var bits1 = dataView.getUint8Bits();
    bits1.getBits(1);
    bits1.getBits(1);
    statusField.open_drain_output_on = bits1.getBits(1);
    bits1.getBits(1);
    bits1.getBits(1);
    bits1.getBits(1);
    statusField.lumalink_connected = bits1.getBits(1);
    statusField.lumalink_connected_after_boot = bits1.getBits(1);
  }

  result.status = statusField;

  result.downlink_rssi__dBm = -1 * dataView.getUint8();

  result.downlink_snr__dB = dataView.getInt8();

  result.mcu_temperature__C = dataView.getInt8();

  var alertsSent = true;
  if (header_below_1_1_4) {
    var bits2 = dataView.getUint8Bits();
    bits2.getBits(1); // legacy thr
    var ldrSent = bits2.getBits(1);
    var odOn = bits2.getBits(1);
    bits2.getBits(1);
    result.status.open_drain_output_on = odOn;
    alertsSent = bits2.getBits(1);

    if (ldrSent) {
      result.ldr_input_value = dataView.getUint8();
    }

  }

  if (alertsSent) {
    var bits4 = dataView.getUint8Bits();
    bits4.getBits(4);
    var alertVolt = bits4.getBits(1);
    var alertLamp = bits4.getBits(1);
    var alertPower = bits4.getBits(1);
    var alertPF = bits4.getBits(1);

    var alerts = {};
    alerts.voltage_alert_in_24h = alertVolt;
    alerts.lamp_error_alert_in_24h = alertLamp;
    alerts.power_alert_in_24h = alertPower;
    alerts.power_factor_alert_in_24h = alertPF;
    result.active_alerts = alerts;

    if (alertVolt) {
      err.warnings.push('voltage_alert_in_24h');
    }
    if (alertLamp) {
      err.warnings.push('lamp_error_alert_in_24h');
    }
    if (alertPower) {
      err.warnings.push('power_alert_in_24h');
    }
    if (alertPF) {
      err.warnings.push('power_factor_alert_in_24h');
    }
  }

  if (!header_below_1_1_4) {
    var senorSrcLeft = dataView.getUint8();
    result.sensor_source = {};
    while (senorSrcLeft > 0) {
      var header = dataView.getUint8();
      senorSrcLeft = senorSrcLeft - 1;
      var consumed_len = decodeSensorSource(dataView, header, result);
      if (consumed_len == 0) {
        err.errors.push("unsupported_sensor_source");
        // consume all leftover bytes assigned for sensor_source so that future sensor sources would not break the code
        dataView.getRaw(senorSrcLeft);
        senorSrcLeft = 0;
      }
      else {
        senorSrcLeft = senorSrcLeft - consumed_len;
      }
    }
    if (senorSrcLeft < 0) {
      err.errors.push('error_decoding_sensor_source');
    }
  }

  result.dimming_source = [];
  while (dataView.availableLen()) {
    result.dimming_source.push(dimmingSourceParser(dataView, err));
  }
}

function usageConsumptionParse(dataView, err) {
  var result = {};
  var addr = dataView.getUint8();
  result.address = addressParse(addr, 'internal_measurement', err);

  var bits = dataView.getUint8Bits();
  if (bits.getBits(1)) {
    result.active_energy__Wh = dataView.getUint32();
  }
  if (bits.getBits(1)) {
    result.active_power__W = dataView.getUint16();
  }
  if (bits.getBits(1)) {
    result.load_side_energy__Wh = dataView.getUint32();
  }
  if (bits.getBits(1)) {
    result.load_side_power__W = dataView.getUint16();
  }
  if (bits.getBits(1)) {
    var rawPf = dataView.getUint8();
    result.power_factor = rawPf === 0xFF ? 'unknown' : (rawPf / 100.0);
  }
  if (bits.getBits(1)) {
    result.mains_voltage__V = dataView.getUint8();
  }
  if (bits.getBits(1)) {
    result.driver_operating_time__h = Math.round(dataView.getUint32() / 3600);
  }
  if (bits.getBits(1)) {
    result.lamp_on_time__s = dataView.getUint32();
  }
  return result;
}
function usageParser(dataView, result, err) {
  if (dataView.getUint8() !== 0) {
    err.errors.push('invalid_packet_type');
    return;
  }

  result.packet_type = 'usage_packet';

  result.consumption = [];
  while (dataView.availableLen()) {
    result.consumption.push(usageConsumptionParse(dataView, err));
  }
}

function deviceConfigParser(config, err) {
  switch (config) {
    case 0:
      return 'dali';
    case 1:
      return 'dali_nc';
    case 2:
      return 'dali_no';
    case 3:
      return 'analog_nc';
    case 4:
      return 'analog_no';
    case 5:
      return 'dali_analog_nc';
    case 6:
      return 'dali_analog_no';
    case 7:
      return 'dali_analog_nc_no';
    default:
      err.errors.push('invalid_device_config');
      return 'invalid_config';
  }
}

function optionalFeaturesParser(byte) {
  var res = {};
  var bits = new BitExtract(byte);
  bits.getBits(1);
  bits.getBits(1);
  res.dig_input = bits.getBits(1);
  res.ldr_input = bits.getBits(1);
  res.open_drain_output = bits.getBits(1);
  res.metering = bits.getBits(1);
  bits.getBits(1);
  bits.getBits(1);
  return res;
}

function daliSupplyParse(data, err) {
  if (data < 0x70) {
    return data;
  }
  switch (data) {
    case 0x7E:
      return 'bus_high';
    case 0x7f:
      err.warnings.push('dali_bus_error');
      return 'bus_error';
    default:
      return 'invalid_value';
  }
}

function resetReasonParse(byte, err) {
  var res = [];
  var bits = new BitExtract(byte);
  if (bits.getBits(1)) {
    res.push('reset_0');
  }
  if (bits.getBits(1)) {
    res.push('watchdog_reset');
    err.warnings.push('watchdog_reset');
  }
  if (bits.getBits(1)) {
    res.push('soft_reset');
  }
  if (bits.getBits(1)) {
    res.push('reset_3');
  }
  if (bits.getBits(1)) {
    res.push('reset_4');
  }
  if (bits.getBits(1)) {
    res.push('reset_5');
  }
  if (bits.getBits(1)) {
    res.push('reset_6');
  }
  if (bits.getBits(1)) {
    res.push('reset_7');
  }
  return res;
}

function bootParser(dataView, result, err) {
  result.packet_type = 'boot_packet';

  result.device_serial = intToHexStr(dataView.getUint32(), 8);

  // eslint-disable-next-line no-bitwise
  result.firmware_version = dataView.getUint8() + '.' + dataView.getUint8() + '.' + dataView.getUint8();

  result.device_unix_epoch = decodeUnixEpoch(dataView.getUint32(), err);

  result.device_config = deviceConfigParser(dataView.getUint8(), err);

  result.optional_features = optionalFeaturesParser(dataView.getUint8());

  var daliBits = dataView.getUint8Bits();
  result.dali_supply_state__V = daliSupplyParse(daliBits.getBits(7), err);
  result.dali_power_source_external = daliBits.getBits(1) ? 'external' : 'internal';

  var driver = dataView.getUint8Bits();
  result.dali_addressed_driver_count = driver.getBits(7);
  var unadressed = driver.getBits(1);
  result.dali_unaddressed_driver_found = unadressed;
  if (unadressed) {
    err.warnings.push("unadressed_dali_driver_on_bus");
  }

  if (dataView.availableLen()) {
    result.reset_reason = resetReasonParse(dataView.getUint8(), err);
  }
}

function errorCodeParser(reason) {
  switch (reason) {
    case 0x00:
      return 'n/a';
    case 0x01:
      return 'n/a';
    case 0x02:
      return 'unknown_fport';
    case 0x03:
      return 'packet_size_short';
    case 0x04:
      return 'packet_size_long';
    case 0x05:
      return 'value_error';
    case 0x06:
      return 'protocol_parse_error';
    case 0x07:
      return 'reserved_flag_set';
    case 0x08:
      return 'invalid_flag_combination';
    case 0x09:
      return 'unavailable_feature_request';
    case 0x0A:
      return 'unsupported_header';
    case 0x0B:
      return 'unreachable_hw_request';
    case 0x0C:
      return 'address_not_available';
    case 0x0D:
      return 'internal_error';
    case 0x0E:
      return 'packet_size_error';
    case 0x81:
      return 'profile_id_seq_error';
    case 0x82:
      return 'profile_destination_eror';
    case 0x83:
      return 'profile_days_error';
    case 0x84:
      return 'profile_step_count_error';
    case 0x85:
      return 'profile_step_value_error';
    case 0x86:
      return 'profile_step_unsorted_error';
    default:
      return 'invalid_error_code';
  }
}

function configFailedParser(dataView, result, err) {
  result.packet_type = 'invalid_downlink_packet';
  result.downlink_from_fport = dataView.getUint8();
  var error = errorCodeParser(dataView.getUint8());
  result.error_reason = error;
  err.warnings.push('downlink_error ' + error);
}
function decodeFport99(dataView, result, err) {
  var header = dataView.getUint8();
  switch (header) {
    case 0x00:
      bootParser(dataView, result, err);
      return;
    case 0x13:
      configFailedParser(dataView, result, err);
      return;
    default:
      err.errors.push('invalid_packet_type');
  }
}

function decodeFport61(dataView, result, err) {
  var header = dataView.getUint8();
  var rawByte2 = dataView.getUint8();
  // eslint-disable-next-line no-bitwise
  var len = rawByte2 >> 4;
  switch (header) {
    case 0x80:
      result.packet_type = 'dig_input_notification';
      if (len === 2) {
        result.dig_input_event_counter = dataView.getUint16();
      }
      else if (len === 4) {
        var bit2 = new BitExtract(rawByte2);
        result.dig_input_on = bit2.getBits(1);
        result.dig_input_event_counter = dataView.getUint32();
      }
      else {
        err.errors.push('invalid_packet_length');
      }
      return;
    case 0x81:
      result.packet_type = 'ldr_input_notification';
      if (len !== 2) {
        err.errors.push('invalid_packet_length');
        return;
      }

      var state = dataView.getUint8Bits().getBits(1);
      var val = dataView.getUint8();
      result.ldr_input_on = state;
      result.ldr_input_value = val;
      return;
    case 0x83:
      result.packet_type = 'dali_driver_alert';

      result.drivers = [];
      while (dataView.availableLen()) {
        result.drivers.push(decodeDaliStatus(dataView, err));
      }
      return;
    case 0x84:
      result.packet_type = 'metering_alert';
      var cond = new BitExtract(rawByte2);

      var lampError = cond.getBits(1);
      var overCurrent = cond.getBits(1);
      var underVoltage = cond.getBits(1);
      var overVoltage = cond.getBits(1);
      var lowPowerFactor = cond.getBits(1);

      result.lamp_error_alert = lampError;
      result.over_current_alert = overCurrent;
      result.under_voltage_alert = underVoltage;
      result.over_voltage_alert = overVoltage;
      result.low_power_factor_alert = lowPowerFactor;

      if (lampError) err.warnings.push('metering_lamp_error');
      if (overCurrent) err.warnings.push('metering_over_current');
      if (underVoltage) err.warnings.push('metering_under_voltage');
      if (overVoltage) err.warnings.push('metering_over_voltage');
      if (lowPowerFactor) err.warnings.push('metering_low_power_factor');

      result.power__W = dataView.getUint16();

      result.voltage__V = dataView.getUint16();

      result.power_factor = dataView.getUint8() / 100;
      return;
    case 0x85:
      result.packet_type = 'deprecated_light_sensor_notification';
      result.active_dim_step = rawByte2;
      return;
    default:
      err.errors.push('invalid_packet_type');
  }
}
// DOWNLINK ONLY THINGS

function decodeFport49(dataView, result, err) {
  var header = dataView.getUint8();
  switch (header) {
    case 0x01:
      result.packet_type = 'deprecated_ldr_input_config_request';
      return;
    case 0x03:
      result.packet_type = 'deprecated_dig_input_config_request';
      return;
    case 0x07:
      result.packet_type = 'status_config_request';
      return;
    case 0x09:
      result.packet_type = 'time_config_packet';
      return;
    case 0x0B:
      result.packet_type = 'usage_config_request';
      return;
    case 0x0D:
      result.packet_type = 'boot_delay_config_request';
      return;
    case 0x15:
      result.packet_type = 'onboard_led_config_request';
      return;
    case 0x16:
      result.packet_type = 'metering_alert_confic_request';
      return;
    case 0x52:
      result.packet_type = 'multicast_config_request';
      var mcDevice = dataView.getUint8();
      result.multicast_device = mcDevice === 0xFF ? 'all' : mcDevice;
      return;
    case 0x20:
      result.packet_type = 'calendar_config_request';
      return;
    case 0x21:
      result.packet_type = 'profile_config_request';
      var pid = dataView.getUint8();
      result.profile_id = pid === 0xFF ? 'all_profiles' : pid;
      return;
    case 0x22:
      result.packet_type = 'fade_config_request';
      return;
    case 0x23:
      result.packet_type = 'holiday_config_request';
      return;
    case 0x24:
      result.packet_type = 'dali_monitor_config_request';
      return;
    case 0x25:
      result.packet_type = 'fallback_dim_config_request';
      return;
    case 0x26:
      result.packet_type = 'location_config_request';
      return;
    case 0x27:
      result.packet_type = 'lumalink_config_request';
      return;
    case 0x28:
      result.packet_type = 'dig_input_config_request';
      return;
    case 0x29:
      result.packet_type = 'light_input_config_request';
      return;
    case 0x2A:
      result.packet_type = 'dim_notify_config_request';
      return;
    case 0x2B:
      result.packet_type = 'interface_type_config_request';
      return;
    default:
      err.errors.push('invalid_packet_type');
  }
}

function decodeFport51(dataView, result, err) {
  var header = dataView.getUint8();
  switch (header) {
    case 0xFF:
      result.packet_type = 'activate_dfu_command';
      return;
    case 0xFE:
      result.packet_type = 'restart_controller_command';
      return;
    default:
      err.errors.push('invalid_command');
  }
}

function decodeByFport(fport, bytes, result, err) {
  var dataView = new BinaryExtract(bytes);
  if (dataView.availableLen() === 0) {
    err.errors.push('empty_payload');
  } else if (fport === 23) {
    statusParser1_1(dataView, result, err);
  } else if (fport === 26) {
    usageParser(dataView, result, err);
  } else if (fport === 49) {
    decodeFport49(dataView, result, err);
  } else if (fport === 50) {
    decodeFport50(dataView, result, err);
  } else if (fport === 51) {
    decodeFport51(dataView, result, err);
  } else if (fport === 60) {
    decodeFport60(dataView, result, err);
  } else if (fport === 61) {
    decodeFport61(dataView, result, err);
  } else if (fport === 99) {
    decodeFport99(dataView, result, err);
  } else {
    err.errors.push('invalid_fport');
  }

  if (dataView.availableLen() !== 0) {
    err.errors.push('invalid_payload_length_long');
  }
}

function decodeRaw(fport, bytes) {
  var res = {};
  var err = { errors: [], warnings: [] };
  try {
    decodeByFport(fport, bytes, res, err);
  } catch (error) {
    err.errors.push("decoder_error " + error.message);
  }
  return { data: res, errors: err.errors, warnings: err.warnings };
}

// You need only one entrypoint, others can be removed.

// entry point for TTN new api
function decodeDownlink(input) {
  return decodeRaw(input.fPort, input.bytes);
}

// entry point for TTN new api
function decodeUplink(input) {
  return decodeRaw(input.fPort, input.bytes);
}

// entry point for TTN old version
function Decoder(bytes, fport) {
  return decodeRaw(fport, bytes);
}

// entry point for Chirpstack
function Decode(fport, bytes) {
  return decodeRaw(fport, bytes);
}




// END THE COPY SELECTION HERE

function filterForHex(raw) {
    return raw.replace(/[^a-fA-F0-9]/g,'');
}

function filterForBase64(raw) {
    return raw.replace(/[^a-zA-z0-9+/=]/g,'');
}

function hexToBytes(hex) {
    for (var bytes = [], c = 0; c < hex.length; c += 2)
    bytes.push(parseInt(hex.substr(c, 2), 16));
    return bytes;
}

function base64ToBytes(base64) {
    try {
        return Uint8Array.from(atob(base64), c => c.charCodeAt(0))
    } catch(err) {
        return [];
    }
}

function load_packet_lookup() {
  var queryString = window.location.search;
  var urlParams = new URLSearchParams(queryString);
  var packet = urlParams.get('packet_type');

  var selectElement = document.getElementById('configKeysDropdown');

  selectElement.innerHTML = '';
  for (var key in config_packet_list) {
    var option = document.createElement('option');
    option.text = key;
    selectElement.add(option);
  }

  if (packet && config_packet_list.hasOwnProperty(packet)) {
    selectElement.value = packet; // Select the option corresponding to the packet type
    updateFunction(packet); // Trigger the update function with the selected packet type
  } else {
    if (selectElement.options.length > 0) {
      updateFunction(selectElement.options[0].value); // Trigger the update function with the default option
    }
  }

  selectElement.addEventListener('change', function () {
    updateFunction(this.value); // Trigger the update function when an option is selected
  });
}


function updateFunction(selectedKey) {
  var jsonString = JSON.stringify(config_packet_list[selectedKey], null, 2);
  document.getElementById('payload_raw').value = jsonString;
  dataInputHandler();
  replaceURLParams(selectedKey);
}


function runOnPageLoad() {
  var queryString = window.location.search;
  var urlParams = new URLSearchParams(queryString);
  var packet = urlParams.get('packet_type');
  if (packet) {
    load_packet_lookup(packet);
  } else {
    load_packet_lookup();
  }
}

window.onload = runOnPageLoad;



window.onload = runOnPageLoad;

function bytesToHexStr(byteArr) {
  var res = '';
  for (var i = 0; i < byteArr.length; i += 1) {
    res += ('00' + byteArr[i].toString(16)).slice(-2).toUpperCase();
  }
  return res;
}

function hexToBytes(hex) {
  for (var bytes = [], c = 0; c < hex.length; c += 2)
  bytes.push(parseInt(hex.substr(c, 2), 16));
  return bytes;
}

function strickOutput(res) {
  var warningDiv = document.getElementById('warning');
  var errorDiv = document.getElementById("error");
  if (warningDiv.innerText.trim() || errorDiv.innerText.trim()) {
    document.getElementById('payload_strick').innerText = '';
  } else {
    var fport = document.getElementById('fPort').innerText;
    var hex = document.getElementById('hexValue').innerText;
    var buffer = hexToBytes(hex);
    var decoded = decodeRaw(parseInt(fport), buffer);
    console.log(decoded);
    var str_json = JSON.stringify(decoded, null, 2).trim();
    console.log(str_json);
    document.getElementById('payload_strick').innerText = str_json;
  }
}

function replaceURLParams(packet_type) {
  var url = new URL(window.location);
  var searchParams = url.searchParams;

  if (packet_type !== '') {
    searchParams.set('packet_type', packet_type);
  } else {
    searchParams.delete('packet_type');
  }

  var newUrl = url.protocol + '//' + url.host + url.pathname + '?' + searchParams.toString();
  window.history.replaceState({}, '', newUrl);
}

function setOutput(res) {
  var hex = bytesToHexStr(res['bytes']);
  document.getElementById("hexValue").innerText = hex;
  document.getElementById("fPort").innerText = res['fPort'];
  var warnings = res['warnings'];
  var warning_items = '';
  for (var i = 0; i< warnings.length; i++){
    warning_items += warnings[i] + '<br>';
  }
  document.getElementById('warning').innerHTML = warning_items;
  var errors = res['errors'];
  var error_items = '';
  for (var i = 0; i < errors.length; i++){
    error_items += errors[i] + '<br>';
  }
  document.getElementById("error").innerHTML = error_items;
  strickOutput()
}

var dataInputHandler = function(e) {
  var raw = document.getElementById('payload_raw').value;
  try {
      var jsonData = JSON.parse(raw);
      var res = rawEncode(jsonData);
      setOutput(res);
  } catch (error) {
      document.getElementById("error").innerHTML = error.message;
      strickOutput()
  }
}


document.getElementById('payload_raw').addEventListener('input', dataInputHandler);

</script>

</body>
</html>
